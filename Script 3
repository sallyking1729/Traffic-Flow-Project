# -*- coding: utf-8 -*-
"""
Traffic flow for different maximum velocities
"""
import numpy as np
import matplotlib.pyplot as plt

vmax=1 #max velocity
number_of_vmax=11
l=250 #length of road
real_l=l*7.5 #convert the value of l to a real life distance
iterations=120 #number of iterations
probability=0.1 #probability of random breaking
cars_max=180 #max density of cars
#empty arrays to store the values for plotting
top_flows=np.array([])
top_stds=np.array([])
vmax_vals=np.array([])
   

while vmax<number_of_vmax: 
    cars=1#number of cars
    densities=np.array([])
    av_points=np.array([])
    while cars<cars_max:
        n=0 #counter for iterations
        diagram=np.empty((0, l)) #emptry array to store iterations
        velocities=np.zeros(cars) #initial velocities of cars
        positions=np.round(np.linspace(1,l,cars)).astype(int) #initial positions of cars
       
        points=np.array([])
        
        #main loop to do iterations
        while n<iterations:
            
            #rule 1 - increase each car velocity by 1 if smaller than vmax
            car_index=0
            while car_index<cars:
                if velocities[car_index]<vmax:
                    velocities[car_index]+=1
                car_index=car_index+1
                
            #rule 2 - slow car down if it gets too close to the next car
            car_index=0
            while car_index<cars:
                if car_index==cars-1:
                    next_index=0
                else:
                    next_index=car_index+1
                if positions[next_index]>positions[car_index]:
                    hops=np.abs(positions[next_index]-positions[car_index])
                else:
                    hops=l-np.abs(positions[next_index]-positions[car_index])
                spacing=hops-1
                if velocities[car_index]>spacing:
                    velocities[car_index]=hops-1
                car_index=car_index+1
                
            #rule 3 - randomly slow cars 
            car_index=0
            probabilities=np.random.rand(cars) #new set of probabilities for each iteration
            sort_idx=np.argsort(positions) #sort positions left to right
            inverse=np.argsort(sort_idx) #inverse sort to put array back in correct order after loop
            sorted_velocities=velocities[sort_idx]
            sorted_probabilities=probabilities[sort_idx]
            while car_index<cars:
                if sorted_velocities[car_index]>0 and probabilities[car_index]<probability:
                    sorted_velocities[car_index]=sorted_velocities[car_index]-1
                car_index=car_index+1
                velocities=sorted_velocities[inverse]
        
            #rule 4 - advance the car by v sites
            car_index=0
            while car_index<cars:
                positions[car_index]=positions[car_index]+velocities[car_index]
                if positions[car_index]>l: #looping
                    positions[car_index]=positions[car_index]-l   
                car_index=car_index+1
            n=n+1
        
            density=cars/real_l
            point=(1/l)*(np.sum(velocities))*3600
            points=np.append(points,point)
        #calculate the average flow over 120 timesteps  
        av_point=np.mean(points)    
        av_points=np.append(av_points,av_point)
        densities=np.append(densities,density)   
        
        cars=cars+1
    
     
    #calculate an average of the top 10 flow values
    top_flow=np.sort(av_points)[-10:]
    top_average=np.mean(top_flow)    
    top_std=np.std(top_flow)
    
    top_flows=np.append(top_flows,top_average)
    top_stds=np.append(top_stds,top_std)
    vmax_vals=np.append(vmax_vals,vmax)
    vmax=vmax+1

#plot the figure 
cmap = plt.cm.plasma
plt.plot(vmax_vals,top_flows,'*',color=cmap(0.2))  
plt.xlabel('Maximum Velocity / Cells per Timestep')
plt.ylabel('Peak Traffic flow / Cars per hour')
z=np.polyfit(vmax_vals,top_flows,3)
p=np.poly1d(z)
plt.plot(vmax_vals,p(vmax_vals),color=cmap(0.4))


